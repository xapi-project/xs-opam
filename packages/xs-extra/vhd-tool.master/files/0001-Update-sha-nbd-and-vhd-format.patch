From e7f8a0a05a71ea8ef5538e9cfcd84446e1946adf Mon Sep 17 00:00:00 2001
From: Yarsin He <yarsin.he@citrix.com>
Date: Tue, 12 Dec 2017 15:29:06 +0000
Subject: [PATCH] Updates to make xs-opam build on next

Signed-off-by: Yarsin He <yarsin.he@citrix.com>
Signed-off-by: Marcello Seri <marcello.seri@citrix.com>
---
 cli/get_vhd_vsize.ml |  12 +++---
 cli/sparse_dd.ml     |   4 +-
 src/impl.ml          | 108 +++++++++++++++++++++++++--------------------------
 src/jbuild           |   4 +-
 vhd-tool.opam        |   3 +-
 5 files changed, 66 insertions(+), 65 deletions(-)

diff --git a/cli/get_vhd_vsize.ml b/cli/get_vhd_vsize.ml
index 07b0d1b..66e1824 100644
--- a/cli/get_vhd_vsize.ml
+++ b/cli/get_vhd_vsize.ml
@@ -1,15 +1,15 @@
 open Lwt
 
-module Impl = Vhd.F.From_file(Vhd_lwt.IO)
+module Impl = Vhd_format.F.From_file(Vhd_format_lwt.IO)
 open Impl
-open Vhd.F
-open Vhd_lwt.IO
+open Vhd_format.F
+open Vhd_format_lwt.IO
 
 module In = From_input(Input)
 open In
 
 let get_vhd_vsize filename =
-  Vhd_lwt.IO.openfile filename false >>= fun fd ->
+  Vhd_format_lwt.IO.openfile filename false >>= fun fd ->
   let rec loop = function
     | End -> return ()
     | Cons (hd, tl) ->
@@ -23,8 +23,8 @@ let get_vhd_vsize filename =
       end;
       tl () >>= fun x ->
       loop x in
-  openstream (Input.of_fd (Vhd_lwt.IO.to_file_descr fd)) >>= fun stream ->
-  loop stream >>= fun () -> Vhd_lwt.IO.close fd
+  openstream (Input.of_fd (Vhd_format_lwt.IO.to_file_descr fd)) >>= fun stream ->
+  loop stream >>= fun () -> Vhd_format_lwt.IO.close fd
 
 let _ =
   let t = get_vhd_vsize Sys.argv.(1) in
diff --git a/cli/sparse_dd.ml b/cli/sparse_dd.ml
index 4213507..a08549a 100644
--- a/cli/sparse_dd.ml
+++ b/cli/sparse_dd.ml
@@ -55,7 +55,7 @@ let options =
         name, Arg.String (fun x -> var_ref := Some x), (fun () -> string_opt !var_ref), description
     in
     [
-    "unbuffered", Arg.Bool (fun b -> Vhd_lwt.File.use_unbuffered := b), (fun () -> string_of_bool !Vhd_lwt.File.use_unbuffered), "use unbuffered I/O via O_DIRECT";
+    "unbuffered", Arg.Bool (fun b -> Vhd_format_lwt.File.use_unbuffered := b), (fun () -> string_of_bool !Vhd_format_lwt.File.use_unbuffered), "use unbuffered I/O via O_DIRECT";
     "encryption-mode", Arg.String (fun x -> encryption_mode := encryption_mode_of_string x), (fun () -> string_of_encryption_mode !encryption_mode), "how to use encryption";
     (* Want to ignore bad values for "nice" etc. so not using Arg.Int *)
     str_option "nice" nice "If supplied, the scheduling priority will be set using this value as argument to the 'nice' command.";
@@ -200,7 +200,7 @@ let progress_cb =
 		last_percent := new_percent
 
 let _ =
-	Vhd_lwt.File.use_unbuffered := true;
+	Vhd_format_lwt.File.use_unbuffered := true;
 	Xcp_service.configure ~options ();
 
 	let src = match !src with
diff --git a/src/impl.ml b/src/impl.ml
index 634802a..4a098c2 100644
--- a/src/impl.ml
+++ b/src/impl.ml
@@ -18,9 +18,9 @@ open Lwt
 
 external sendfile: Unix.file_descr -> Unix.file_descr -> int64 -> int64 = "stub_sendfile64"
 
-module F = Vhd.F.From_file(Vhd_lwt.IO)
-module In = Vhd.F.From_input(Input)
-module Channel_In = Vhd.F.From_input(struct
+module F = Vhd_format.F.From_file(Vhd_format_lwt.IO)
+module In = Vhd_format.F.From_input(Input)
+module Channel_In = Vhd_format.F.From_input(struct
   include Lwt
   type fd = Channels.t
   let read c buf = c.Channels.really_read buf
@@ -39,7 +39,7 @@ end)
 open F
 (*
 open Vhd
-open Vhd_lwt
+open Vhd_format_lwt
 *)
 let vhd_search_path = "/dev/mapper"
 
@@ -53,7 +53,7 @@ let get common filename key =
     let key = require "key" key in
     let t =
       Vhd_IO.openfile filename false >>= fun t ->
-      let result = Vhd.F.Vhd.Field.get t key in
+      let result = Vhd_format.F.Vhd.Field.get t key in
       Vhd_IO.close t >>= fun () ->
       return result in
     match Lwt_main.run t with
@@ -65,7 +65,7 @@ let get common filename key =
     | Failure x ->
       `Error(true, x)
     | Not_found ->
-      `Error(true, Printf.sprintf "Unknown key. Known keys are: %s" (String.concat ", " Vhd.F.Vhd.Field.list))
+      `Error(true, Printf.sprintf "Unknown key. Known keys are: %s" (String.concat ", " Vhd_format.F.Vhd.Field.list))
 
 let info common filename =
   try
@@ -73,10 +73,10 @@ let info common filename =
     let t =
       Vhd_IO.openfile filename false >>= fun t ->
       let all = List.map (fun f ->
-        match Vhd.F.Vhd.Field.get t f with
+        match Vhd_format.F.Vhd.Field.get t f with
         | Some v -> [ f; v ]
         | None -> [ f; "<missing field>" ]
-      ) Vhd.F.Vhd.Field.list in
+      ) Vhd_format.F.Vhd.Field.list in
       print_table ["field"; "value"] all;
       return () in
     Lwt_main.run t;
@@ -89,11 +89,11 @@ let contents common filename =
     let filename = require "filename" filename in
     let t =
       let open In in
-      Vhd_lwt.IO.openfile filename false >>= fun fd ->
+      Vhd_format_lwt.IO.openfile filename false >>= fun fd ->
       let rec loop = function
       | End -> return ()
       | Cons (hd, tl) ->
-        let open Vhd.F in
+        let open Vhd_format.F in
         begin match hd with
         | Fragment.Header x ->
           Printf.printf "Header\n"
@@ -108,7 +108,7 @@ let contents common filename =
         end;
         tl () >>= fun x ->
         loop x in
-      openstream (Input.of_fd (Vhd_lwt.IO.to_file_descr fd)) >>= fun stream ->
+      openstream (Input.of_fd (Vhd_format_lwt.IO.to_file_descr fd)) >>= fun stream ->
       loop stream in
     Lwt_main.run t;
     `Ok ()
@@ -146,7 +146,7 @@ let check common filename =
     let filename = require "filename" filename in
     let t =
       Vhd_IO.openchain ~path:common.path filename false >>= fun vhd ->
-      Vhd.F.Vhd.check_overlapping_blocks vhd;
+      Vhd_format.F.Vhd.check_overlapping_blocks vhd;
       return () in
     Lwt_main.run t;
     `Ok ()
@@ -179,7 +179,7 @@ let no_progress_bar _ _ = ()
 
 let stream_human common _ s _ _ ?(progress = no_progress_bar) () =
   let decimal_digits =
-    let open Vhd.F in
+    let open Vhd_format.F in
     (* How much space will we need for the sector numbers? *)
     let sectors = Int64.(shift_right (add s.size.total 511L) sector_shift) in
     let decimal_digits = int_of_float (ceil (log10 (Int64.to_float sectors))) in
@@ -193,8 +193,8 @@ let stream_human common _ s _ _ ?(progress = no_progress_bar) () =
   fold_left (fun sector x ->
     Printf.printf "%s: %s\n"
       (padto ' ' decimal_digits (Int64.to_string sector))
-      (Vhd.Element.to_string x);
-    return (Int64.add sector (Vhd.Element.len x))
+      (Vhd_format.Element.to_string x);
+    return (Int64.add sector (Vhd_format.Element.len x))
   ) 0L s.elements >>= fun _ ->
   Printf.printf "# end of stream\n";
   return None
@@ -206,7 +206,7 @@ let stream_nbd common c s prezeroed _ ?(progress = no_progress_bar) () =
   Client.negotiate c "" >>= fun (server, size, flags) ->
   (* Work to do is: non-zero data to write + empty sectors if the
      target is not prezeroed *)
-  let total_work = let open Vhd.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
+  let total_work = let open Vhd_format.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
   let p = progress total_work in
 
   ( if not prezeroed then expand_empty s else return s ) >>= fun s ->
@@ -217,14 +217,14 @@ let stream_nbd common c s prezeroed _ ?(progress = no_progress_bar) () =
       | `Sectors data ->
         Client.write server (Int64.mul sector 512L) [data] >>= begin
           function
-          | `Ok () -> return Int64.(of_int (Cstruct.len data))
-          | `Error e -> fail (Failure "Got error from NBD library")
+          | Ok () -> return Int64.(of_int (Cstruct.len data))
+          | Error e -> fail (Failure "Got error from NBD library")
         end
       | `Empty n -> (* must be prezeroed *)
         assert prezeroed;
         return 0L
-      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd.Element.to_string x))) ) >>= fun work ->
-    let sector = Int64.add sector (Vhd.Element.len x) in
+      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd_format.Element.to_string x))) ) >>= fun work ->
+    let sector = Int64.add sector (Vhd_format.Element.len x) in
     let work_done = Int64.add work_done work in
     p work_done;
     return (sector, work_done)
@@ -236,7 +236,7 @@ let stream_nbd common c s prezeroed _ ?(progress = no_progress_bar) () =
 let stream_chunked common c s prezeroed _ ?(progress = no_progress_bar) () =
   (* Work to do is: non-zero data to write + empty sectors if the
      target is not prezeroed *)
-  let total_work = let open Vhd.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
+  let total_work = let open Vhd_format.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
   let p = progress total_work in
 
   ( if not prezeroed then expand_empty s else return s ) >>= fun s ->
@@ -254,8 +254,8 @@ let stream_chunked common c s prezeroed _ ?(progress = no_progress_bar) () =
       | `Empty n -> (* must be prezeroed *)
         assert prezeroed;
         return 0L
-      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd.Element.to_string x))) ) >>= fun work ->
-    let sector = Int64.add sector (Vhd.Element.len x) in
+      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd_format.Element.to_string x))) ) >>= fun work ->
+    let sector = Int64.add sector (Vhd_format.Element.len x) in
     let work_done = Int64.add work_done work in
     p work_done;
     return (sector, work_done)
@@ -271,7 +271,7 @@ let stream_chunked common c s prezeroed _ ?(progress = no_progress_bar) () =
 let stream_raw common c s prezeroed _ ?(progress = no_progress_bar) () =
   (* Work to do is: non-zero data to write + empty sectors if the
      target is not prezeroed *)
-  let total_work = let open Vhd.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
+  let total_work = let open Vhd_format.F in Int64.(add (add s.size.metadata s.size.copy) (if prezeroed then 0L else s.size.empty)) in
   let p = progress total_work in
 
   ( if not prezeroed then expand_empty s else return s ) >>= fun s ->
@@ -279,7 +279,7 @@ let stream_raw common c s prezeroed _ ?(progress = no_progress_bar) () =
   fold_left (fun work_done x ->
     (match x with
       | `Copy(fd, sector_start, sector_len) ->
-        let fd = Vhd_lwt.IO.to_file_descr fd in
+        let fd = Vhd_format_lwt.IO.to_file_descr fd in
         Lwt_unix.LargeFile.lseek fd (Int64.mul 512L sector_start) Unix.SEEK_SET
         >>= fun (_: int64) ->
         c.Channels.copy_from fd (Int64.mul 512L sector_len)
@@ -305,8 +305,8 @@ let sha1_update_cstruct ctx buffer =
   let buf = buffer.Cstruct.buffer in
   let buffer' : (char, Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t = Bigarray.Array1.sub buf ofs len in
   (* XXX: need a better way to do this *)
-  let buffer'': (int,  Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t = Obj.magic buffer' in
-  Sha1.update_buffer ctx buffer''
+  (* let buffer'': (int,  Bigarray.int8_unsigned_elt, Bigarray.c_layout) Bigarray.Array1.t = Obj.magic buffer' in *)
+  Sha1.update_buffer ctx buffer'
 
 module TarStream = struct
   type t = {
@@ -346,7 +346,7 @@ let stream_tar common c s _ prefix ?(progress = no_progress_bar) () =
     Cstruct.set_uint8 zeroes i 0
   done;
   (* This undercounts by missing the tar headers and occasional empty sector *)
-  let total_work = let open Vhd.F in Int64.(add s.size.metadata s.size.copy) in
+  let total_work = let open Vhd_format.F in Int64.(add s.size.metadata s.size.copy) in
   let p = progress total_work in
 
   expand_copy s >>= fun s ->
@@ -417,19 +417,19 @@ let stream_tar common c s _ prefix ?(progress = no_progress_bar) () =
       (* If n > block_size (in sectors) then we can omit empty blocks *)
       empty { state with next_counter = state.next_counter + 1 } Int64.(sub bytes (of_int block_size))
     end else write state bytes in
-  let module E = Vhd.Element in
+  let module E = Vhd_format.Element in
   fold_left (fun state x ->
     (match x with
       | `Sectors data ->
         input state data
       | `Empty n ->
         empty state (Int64.(mul n 512L))
-      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd.Element.to_string x))) ) >>= fun state ->
+      | _ -> fail (Failure (Printf.sprintf "unexpected stream element: %s" (Vhd_format.Element.to_string x))) ) >>= fun state ->
     let work = Int64.mul (E.len x) 512L in
     let work_done = Int64.add state.work_done work in
     p work_done;
     return { state with work_done }
-  ) (initial s.size.Vhd.F.total) s.elements >>= fun _ ->
+  ) (initial s.size.Vhd_format.F.total) s.elements >>= fun _ ->
   p total_work;
 
   return (Some total_work)
@@ -465,7 +465,7 @@ let serve_vhd_to_raw total_size c dest prezeroed progress _ _ =
   let p = ref None in
 
   let open Channel_In in
-  let open Vhd.F in
+  let open Vhd_format.F in
   let rec loop block_size_sectors_shift last_block blocks_seen = function
     | End -> return ()
     | Cons (Fragment.Header h, tl) -> tl () >>= loop h.Header.block_size_sectors_shift last_block blocks_seen
@@ -475,7 +475,7 @@ let serve_vhd_to_raw total_size c dest prezeroed progress _ _ =
       p := Some (progress total_size);
       tl () >>= loop block_size_sectors_shift last_block blocks_seen
     | Cons (Fragment.Block (offset, data), tl) ->
-      Vhd_lwt.IO.really_write dest (Int64.shift_left offset sector_shift) data >>= fun () ->
+      Vhd_format_lwt.IO.really_write dest (Int64.shift_left offset sector_shift) data >>= fun () ->
       let this_block = Int64.(shift_right offset block_size_sectors_shift) in
       let blocks_seen = if last_block <> this_block then Int64.succ blocks_seen else blocks_seen in
       (match !p with Some p -> p blocks_seen | None -> ());
@@ -544,7 +544,7 @@ let serve_tar_to_raw total_size c dest prezeroed progress expected_prefix ignore
             let this = Int64.(to_int (min remaining (of_int (Cstruct.len buffer)))) in
             let block = Cstruct.sub buffer 0 this in
             c.Channels.really_read block >>= fun () ->
-            Vhd_lwt.IO.really_write dest offset block >>= fun () ->
+            Vhd_format_lwt.IO.really_write dest offset block >>= fun () ->
             if not ignore_checksums then sha1_update_cstruct t.ctx block;
             let remaining = Int64.(sub remaining (of_int this)) in
             let offset = Int64.(add offset (of_int this)) in
@@ -625,7 +625,7 @@ let make_stream common source relative_to source_format destination_format =
       let path = common.path @ [ Filename.dirname vhd ] in
       retry common 3 (fun () -> Vhd_IO.openchain ~path vhd false) >>= fun t ->
       Vhd_IO.close t >>= fun () ->
-      Vhd_lwt.IO.openfile raw false >>= fun raw ->
+      Vhd_format_lwt.IO.openfile raw false >>= fun raw ->
       ( match relative_to with None -> return None | Some f -> Vhd_IO.openchain ~path f false >>= fun t -> Vhd_IO.close t >>= fun () -> return (Some t) ) >>= fun from ->
       Hybrid_input.raw ?from raw t
     | _ ->
@@ -638,7 +638,7 @@ let make_stream common source relative_to source_format destination_format =
       let path = common.path @ [ Filename.dirname vhd ] in
       retry common 3 (fun () -> Vhd_IO.openchain ~path vhd false) >>= fun t ->
       Vhd_IO.close t >>= fun () ->
-      Vhd_lwt.IO.openfile raw false >>= fun raw ->
+      Vhd_format_lwt.IO.openfile raw false >>= fun raw ->
       ( match relative_to with None -> return None | Some f -> Vhd_IO.openchain ~path f false >>= fun t -> Vhd_IO.close t >>= fun () -> return (Some t) ) >>= fun from ->
       Hybrid_input.vhd ?from raw t
     | _ ->
@@ -776,7 +776,7 @@ let write_stream common s destination source_protocol destination_protocol preze
 
           Printf.printf "Time taken: %s\n" (hms (int_of_float time));
           Printf.printf "Physical data rate: %s/sec\n" (add_unit physical_rate);
-          let open Vhd.F in
+          let open Vhd_format.F in
           let speedup = Int64.(to_float s.size.total /. (to_float p)) in
           Printf.printf "Speedup: %.1f\n" speedup;
           Printf.printf "Virtual data rate: %s/sec\n" (add_unit (physical_rate *. speedup));
@@ -791,7 +791,7 @@ let stream_t common args ?(progress = no_progress_bar) () =
 
 let stream common args =
   try
-    Vhd_lwt.File.use_unbuffered := common.Common.unbuffered;
+    Vhd_format_lwt.File.use_unbuffered := common.Common.unbuffered;
 
     let progress_bar = match args with
     | { StreamCommon.progress = true; machine = true } -> machine_progress_bar
@@ -828,27 +828,27 @@ let serve_nbd_to_raw common size c dest _ _ _ _ =
   let rec serve_requests () =
     c.Channels.really_read req >>= fun () ->
     match Request.unmarshal req with
-    | `Error e -> fail e
-    | `Ok request ->
+    | Error e -> fail e
+    | Ok request ->
       if common.Common.debug
       then Printf.fprintf stderr "%s\n%!" (Request.to_string request);
       begin match request.Request.ty with
       | Command.Write ->
         inblocks (fun offset subblock ->
           c.Channels.really_read subblock >>= fun () ->
-          Vhd_lwt.IO.really_write dest offset subblock
+          Vhd_format_lwt.IO.really_write dest offset subblock
         ) request >>= fun () ->
-        Reply.marshal rep { Reply.error = `Ok (); handle = request.Request.handle };
+        Reply.marshal rep { Reply.error = Ok (); handle = request.Request.handle };
         c.Channels.really_write rep
       | Command.Read ->
-        Reply.marshal rep { Reply.error = `Ok (); handle = request.Request.handle };
+        Reply.marshal rep { Reply.error = Ok (); handle = request.Request.handle };
         c.Channels.really_write rep >>= fun () ->
         inblocks (fun offset subblock ->
-          Vhd_lwt.IO.really_read dest offset subblock >>= fun () ->
+          Vhd_format_lwt.IO.really_read dest offset subblock >>= fun () ->
           c.Channels.really_write subblock
         ) request
       | _ ->
-        Reply.marshal rep { Reply.error = `Error `EPERM; handle = request.Request.handle };
+        Reply.marshal rep { Reply.error = Error `EPERM; handle = request.Request.handle };
         c.Channels.really_write rep
       end >>= fun () ->
       serve_requests () in
@@ -868,7 +868,7 @@ let serve_chunked_to_raw _ c dest _ _ _ _ =
         let this = Int32.(to_int (min (of_int twomib) remaining)) in
         let buf = if this < twomib then Cstruct.sub buffer 0 this else buffer in
         c.Channels.really_read buf >>= fun () ->
-        Vhd_lwt.IO.really_write dest offset buf >>= fun () ->
+        Vhd_format_lwt.IO.really_write dest offset buf >>= fun () ->
         let offset = Int64.(add offset (of_int this)) in
         let remaining = Int32.(sub remaining (of_int this)) in
         if remaining > 0l
@@ -899,14 +899,14 @@ let serve_raw_to_raw common size c dest _ progress _ _ =
     let block = Cstruct.sub buffer 0 rounded_n in
     begin
       if n <> rounded_n
-      then Vhd_lwt.IO.really_read dest offset block
+      then Vhd_format_lwt.IO.really_read dest offset block
       else Lwt.return ()
     end >>= fun () ->
     (* Create a cstruct that's an alias to the above block,
        but only as long as the amount of data we're expecting *)
     let block2 = Cstruct.sub block 0 n in
     c.Channels.really_read block2 >>= fun () ->
-    Vhd_lwt.IO.really_write dest offset block >>= fun () ->
+    Vhd_format_lwt.IO.really_write dest offset block >>= fun () ->
     let offset = Int64.(add offset (of_int n)) in
     let remaining = Int64.(sub remaining (of_int n)) in begin
       p Int64.(sub size remaining);
@@ -918,7 +918,7 @@ let serve_raw_to_raw common size c dest _ progress _ _ =
 
 let serve common_options source source_fd source_format source_protocol destination destination_fd destination_format destination_size prezeroed progress machine expected_prefix ignore_checksums =
   try
-    Vhd_lwt.File.use_unbuffered := common_options.Common.unbuffered;
+    Vhd_format_lwt.File.use_unbuffered := common_options.Common.unbuffered;
 
     let source_protocol = protocol_of_string (require "source-protocol" source_protocol) in
 
@@ -959,7 +959,7 @@ let serve common_options source source_fd source_format source_protocol destinat
           Channels.of_raw_fd fd >>= fun c ->
           return c
         | File path ->
-          let fd = Vhd_lwt.File.openfile path false 0 in
+          let fd = Vhd_format_lwt.File.openfile path false 0 in
           Channels.of_raw_fd (Lwt_unix.of_unix_file_descr fd)
         | _ -> failwith (Printf.sprintf "Not implemented: serving from source %s" source) ) >>= fun source_sock ->
       ( match destination_endpoint with
@@ -968,9 +968,9 @@ let serve common_options source source_fd source_format source_protocol destinat
               Lwt_unix.openfile path [ Unix.O_CREAT; Unix.O_RDONLY ] 0o0644 >>= fun fd ->
               Lwt_unix.close fd
             end else return () ) >>= fun () ->
-          Vhd_lwt.IO.openfile path true >>= fun fd ->
+          Vhd_format_lwt.IO.openfile path true >>= fun fd ->
           let size = match destination_size with
-            | None -> Vhd_lwt.File.get_file_size path
+            | None -> Vhd_format_lwt.File.get_file_size path
             | Some x -> x in
           if size=0L
           then fail (Failure "Non-zero size required (either a pre-existing destination file or specified via --destination-size on the command line)")
@@ -984,8 +984,8 @@ let serve common_options source source_fd source_format source_protocol destinat
         | "vhd", NoProtocol -> serve_vhd_to_raw size
         | _, _ -> failwith (Printf.sprintf "Not implemented: receiving format %s via protocol %s" source_format (StreamCommon.string_of_protocol source_protocol)) in
       fn source_sock destination_fd prezeroed progress_bar expected_prefix ignore_checksums >>= fun () ->
-      let fd = Lwt_unix.unix_file_descr (Vhd_lwt.IO.to_file_descr destination_fd) in
-      (try Vhd_lwt.File.fsync fd; return () with _ -> fail (Failure "fsync failed")) in
+      let fd = Lwt_unix.unix_file_descr (Vhd_format_lwt.IO.to_file_descr destination_fd) in
+      (try Vhd_format_lwt.File.fsync fd; return () with _ -> fail (Failure "fsync failed")) in
     Lwt_main.run thread;
     `Ok ()
   with Failure x ->
diff --git a/src/jbuild b/src/jbuild
index 5dc2e10..4d28f54 100644
--- a/src/jbuild
+++ b/src/jbuild
@@ -26,13 +26,13 @@ let () = Printf.ksprintf Jbuild_plugin.V1.send {|
     cstruct
     cohttp.lwt
     io-page.unix
-    nbd.lwt
+    nbd-lwt-unix
     re.str
     sha.sha1
     xapi-tapctl
     tar
     vhd-format
-    vhd-format.lwt
+    vhd-format-lwt
     xenstore.client
     xenstore.unix
     xenstore_transport
diff --git a/vhd-tool.opam b/vhd-tool.opam
index 7c93a98..eb74ad2 100644
--- a/vhd-tool.opam
+++ b/vhd-tool.opam
@@ -18,7 +18,8 @@ depends: [
   "cstruct" {>= "1.0.1" & < "3.0.0"}
   "io-page-unix"
   "lwt" {>= "2.4.3" & < "3.0.0"}
-  "nbd" {>= "1.0.1" & < "3.0.0"}
+  "nbd"
+  "nbd-lwt-unix"
   "re"
   "sha"
   "ssl"
-- 
2.14.1

